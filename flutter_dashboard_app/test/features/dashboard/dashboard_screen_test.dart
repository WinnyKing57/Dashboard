import 'package:flutter/material.dart';
import 'package:flutter_dashboard_app/src/features/dashboard_screen.dart';
import 'package:flutter_dashboard_app/src/features/dashboard/placeholder_widget.dart';
import 'package:flutter_dashboard_app/src/features/dashboard/widgets/notepad_widget.dart';
import 'package:flutter_dashboard_app/src/models/dashboard_item.dart';
import 'package:flutter_dashboard_app/src/models/notepad_data.dart';
import 'package:flutter_dashboard_app/src/models/rss_feed_source.dart';
import 'package:flutter_dashboard_app/src/models/widget_configs/rss_widget_config.dart';
import 'package:flutter_dashboard_app/src/services/dashboard_service.dart';
import 'package:flutter_dashboard_app/src/services/rss_service.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

// Generate Mocks for services
@GenerateMocks([DashboardService, RssService])
import 'dashboard_screen_test.mocks.dart'; // Will be generated by build_runner

void main() {
  late MockDashboardService mockDashboardService;
  late MockRssService mockRssService;

  setUp(() {
    mockDashboardService = MockDashboardService();
    mockRssService = MockRssService();

    // Default mock responses for service methods that return Futures
    when(mockDashboardService.getDashboardItems()).thenReturn([]); // Default to empty
    when(mockRssService.getFeedSources()).thenReturn([]);
    when(mockDashboardService.createAndSavePlaceholderItem(any)).thenAnswer((_) async => DashboardItem(id: 'p${DateTime.now().millisecondsSinceEpoch}', widgetType: 'placeholder', order: 0));
    when(mockDashboardService.createAndSaveNotepadItem(any)).thenAnswer((_) async => DashboardItem(id: 'n${DateTime.now().millisecondsSinceEpoch}', widgetType: 'notepad', order: 0, widgetData: NotepadData(content: '')));
    when(mockDashboardService.createAndSaveRssWidgetConfigItem(any, any)).thenAnswer((_) async => DashboardItem(id: 'r${DateTime.now().millisecondsSinceEpoch}', widgetType: 'rss_summary', order: 0, widgetData: RssWidgetConfig(feedSourceId: 'id', feedSourceName: 'name')));
    when(mockDashboardService.createAndSaveWebRadioStatusItem(any)).thenAnswer((_) async => DashboardItem(id: 'w${DateTime.now().millisecondsSinceEpoch}', widgetType: 'webradio_status', order: 0));
    when(mockDashboardService.deleteDashboardItem(any)).thenAnswer((_) async {});
    when(mockDashboardService.updateDashboardItemOrder(any)).thenAnswer((_) async {});
  });

  Widget createTestableWidget(Widget child) {
    return MaterialApp(
      home: Scaffold(body: child),
    );
  }

  testWidgets('DashboardScreen displays AppBar and Add button', (WidgetTester tester) async {
    await tester.pumpWidget(createTestableWidget(
      DashboardScreen(
        dashboardServiceForTest: mockDashboardService,
        rssServiceForTest: mockRssService,
      ),
    ));
    // _loadDashboardItems is called in initState, which calls _addInitialItems if empty.
    // _addInitialItems calls createAndSave... methods.
    // We need to let these settle.
    await tester.pumpAndSettle();

    expect(find.widgetWithText(AppBar, 'Dashboard'), findsOneWidget);
    expect(find.byIcon(Icons.add), findsOneWidget);
  });

  testWidgets('DashboardScreen displays "No items" message when dashboard is empty and initial setup fails to populate', (WidgetTester tester) async {
    // Specific setup for this test: getDashboardItems returns empty, and create methods also effectively lead to empty state for items.
    when(mockDashboardService.getDashboardItems()).thenReturn([]);
    // Mock create methods to return valid items but assume getDashboardItems will be called again and return empty for this test's purpose.
    // This simulates a scenario where initial items might fail to load or persist in a way that getDashboardItems reflects.

    await tester.pumpWidget(createTestableWidget(
      DashboardScreen(
        dashboardServiceForTest: mockDashboardService,
        rssServiceForTest: mockRssService,
      ),
    ));
    await tester.pumpAndSettle();

    expect(find.text('No items on dashboard. Add some!'), findsOneWidget);
  });

  testWidgets('DashboardScreen displays items from DashboardService', (WidgetTester tester) async {
    final items = [
      DashboardItem(id: 'item1', widgetType: 'placeholder', order: 0),
      DashboardItem(id: 'item2', widgetType: 'notepad', order: 1, widgetData: NotepadData(content: 'Test Note')),
    ];
    when(mockDashboardService.getDashboardItems()).thenReturn(items);

    await tester.pumpWidget(createTestableWidget(
      DashboardScreen(
        dashboardServiceForTest: mockDashboardService,
        rssServiceForTest: mockRssService,
      ),
    ));
    await tester.pumpAndSettle();

    expect(find.byType(PlaceholderWidget), findsOneWidget);
    expect(find.byType(NotepadWidget), findsOneWidget);
    expect(find.text('Test Note'), findsOneWidget);
  });

  testWidgets('Adds Placeholder widget when "Add Placeholder" is tapped', (WidgetTester tester) async {
    // Initial state: no items
    when(mockDashboardService.getDashboardItems()).thenReturn([]);

    // What getDashboardItems returns AFTER an item is added
    final placeholderItem = DashboardItem(id: 'p1', widgetType: 'placeholder', order: 0);
    when(mockDashboardService.createAndSavePlaceholderItem(any)).thenAnswer((_) async {
      // Simulate the item being created and now available
      when(mockDashboardService.getDashboardItems()).thenReturn([placeholderItem]);
      return placeholderItem;
    });

    await tester.pumpWidget(createTestableWidget(
      DashboardScreen(
        dashboardServiceForTest: mockDashboardService,
        rssServiceForTest: mockRssService,
      ),
    ));
    await tester.pumpAndSettle(); // Initial load (empty)

    await tester.tap(find.byIcon(Icons.add));
    await tester.pumpAndSettle(); // Open menu

    await tester.tap(find.text('Add Placeholder'));
    await tester.pumpAndSettle(); // Process tap, trigger service call and reload

    verify(mockDashboardService.createAndSavePlaceholderItem(0)).called(1);
    // Verify that getDashboardItems was called again after adding (part of _loadDashboardItems)
    verify(mockDashboardService.getDashboardItems()).called(atLeast(2)); // Initial + after add
    expect(find.byType(PlaceholderWidget), findsOneWidget); // Check if UI updated
  });

  testWidgets('Adds Notepad widget when "Add Notepad" is tapped', (WidgetTester tester) async {
    when(mockDashboardService.getDashboardItems()).thenReturn([]);
    final notepadItem = DashboardItem(id: 'n1', widgetType: 'notepad', order: 0, widgetData: NotepadData(content: ''));
     when(mockDashboardService.createAndSaveNotepadItem(any)).thenAnswer((_) async {
      when(mockDashboardService.getDashboardItems()).thenReturn([notepadItem]);
      return notepadItem;
    });

    await tester.pumpWidget(createTestableWidget(
      DashboardScreen(
        dashboardServiceForTest: mockDashboardService,
        rssServiceForTest: mockRssService,
      ),
    ));
    await tester.pumpAndSettle();

    await tester.tap(find.byIcon(Icons.add));
    await tester.pumpAndSettle();
    await tester.tap(find.text('Add Notepad'));
    await tester.pumpAndSettle();

    verify(mockDashboardService.createAndSaveNotepadItem(0)).called(1);
    expect(find.byType(NotepadWidget), findsOneWidget);
  });

  testWidgets('Adds RSS Summary widget after selecting a feed', (WidgetTester tester) async {
    when(mockDashboardService.getDashboardItems()).thenReturn([]);
    final sources = [
      RssFeedSource(id: 'rss1', url: 'url1', name: 'Feed 1'),
      RssFeedSource(id: 'rss2', url: 'url2', name: 'Feed 2'),
    ];
    when(mockRssService.getFeedSources()).thenReturn(sources);

    final rssWidgetItem = DashboardItem(id: 'rss_w1', widgetType: 'rss_summary', order: 0, widgetData: RssWidgetConfig(feedSourceId: 'rss1', feedSourceName: 'Feed 1'));
    when(mockDashboardService.createAndSaveRssWidgetConfigItem(any, any)).thenAnswer((_) async {
        when(mockDashboardService.getDashboardItems()).thenReturn([rssWidgetItem]);
        return rssWidgetItem;
    });


    await tester.pumpWidget(createTestableWidget(
      DashboardScreen(
        dashboardServiceForTest: mockDashboardService,
        rssServiceForTest: mockRssService,
      ),
    ));
    await tester.pumpAndSettle();

    await tester.tap(find.byIcon(Icons.add));
    await tester.pumpAndSettle();
    await tester.tap(find.text('Add RSS Summary'));
    await tester.pumpAndSettle(); // Dialog appears

    expect(find.text('Select RSS Feed'), findsOneWidget);
    await tester.tap(find.text('Feed 1'));
    await tester.pumpAndSettle(); // Dialog closes, widget added

    verify(mockDashboardService.createAndSaveRssWidgetConfigItem(0, any)).called(1);
    // Further check would be to find the RssDashboardWidget, but its content depends on RssService.fetchAndCacheFeedItems
    // For now, verifying the call is sufficient for this interaction test.
  });

  testWidgets('Deletes a widget when close button is tapped', (WidgetTester tester) async {
    final itemToDelete = DashboardItem(id: 'item1', widgetType: 'placeholder', order: 0);
    // Initial state: one item
    when(mockDashboardService.getDashboardItems()).thenReturn([itemToDelete]);

    // What getDashboardItems returns AFTER delete
    when(mockDashboardService.deleteDashboardItem(itemToDelete.id)).thenAnswer((_) async {
      when(mockDashboardService.getDashboardItems()).thenReturn([]); // Now empty
    });

    await tester.pumpWidget(createTestableWidget(
      DashboardScreen(
        dashboardServiceForTest: mockDashboardService,
        rssServiceForTest: mockRssService,
      ),
    ));
    await tester.pumpAndSettle();

    expect(find.byType(PlaceholderWidget), findsOneWidget);

    // Find the delete button (close icon) within the PlaceholderWidget.
    // This assumes the delete button is an Icon with Icons.close.
    // The structure is Stack -> Positioned -> Material -> IconButton -> Icon
    final deleteButton = find.descendant(
      of: find.byType(PlaceholderWidget),
      matching: find.byIcon(Icons.close)
    );
    expect(deleteButton, findsOneWidget);

    await tester.tap(deleteButton);
    await tester.pumpAndSettle(); // Process delete and UI update

    verify(mockDashboardService.deleteDashboardItem(itemToDelete.id)).called(1);
    expect(find.byType(PlaceholderWidget), findsNothing); // Widget should be gone
    expect(find.text('No items on dashboard. Add some!'), findsOneWidget); // Empty state
  });
}
