import 'package:flutter/material.dart';
import 'package:flutter_dashboard_app/src/features/dashboard/widgets/notepad_widget.dart';
import 'package:flutter_dashboard_app/src/models/notepad_data.dart';
import 'package:flutter_dashboard_app/src/services/dashboard_service.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

// Generate a Mock for DashboardService
@GenerateMocks([DashboardService])
import 'notepad_widget_test.mocks.dart'; // Generated by build_runner

void main() {
  late MockDashboardService mockDashboardService;

  setUp(() {
    mockDashboardService = MockDashboardService();
    // Provide a default implementation for updateNotepadData to avoid null errors if called.
    when(mockDashboardService.updateNotepadData(any, any)).thenAnswer((_) async {});
  });

  testWidgets('NotepadWidget renders initial content and allows text input', (WidgetTester tester) async {
    final initialData = NotepadData(content: 'Initial note content');
    const dashboardItemId = 'test-notepad-id';

    // It's important that NotepadWidget can access DashboardService.
    // The current NotepadWidget instantiates its own DashboardService.
    // For this test to work with a mock, NotepadWidget would need to accept
    // DashboardService via its constructor (Dependency Injection).
    //
    // Workaround for this test IF NotepadWidget is NOT refactored for DI:
    // We can't directly mock the service it instantiates internally.
    // So, for this iteration, we will test rendering and text input,
    // but testing the save action's interaction with the service is not possible
    // without refactoring NotepadWidget.
    //
    // If NotepadWidget were refactored:
    // await tester.pumpWidget(
    //   MaterialApp(
    //     home: Scaffold(
    //       body: NotepadWidget(
    //         notepadData: initialData,
    //         dashboardItemId: dashboardItemId,
    //         // dashboardService: mockDashboardService, // If DI was implemented
    //       ),
    //     ),
    //   ),
    // );

    // For now, testing without DI for the service in the widget:
     await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: NotepadWidget( // This will use its own real DashboardService instance
            notepadData: initialData,
            dashboardItemId: dashboardItemId,
          ),
        ),
      ),
    );


    // Verify initial content is displayed.
    expect(find.text('Initial note content'), findsOneWidget);
    expect(find.byType(TextFormField), findsOneWidget);

    // Simulate text input.
    await tester.enterText(find.byType(TextFormField), 'Updated note content');
    await tester.pump(); // Rebuild the widget after text input.

    // Verify the TextFormField's value has changed.
    expect(find.text('Updated note content'), findsOneWidget);

    // To test the save button tap with the current structure:
    // The actual service call won't be mocked, but we can verify UI changes (e.g., SnackBar).
    // This makes it more of an integration test for this part.

    // Mock the actual service call if NotepadWidget was refactored:
    // when(mockDashboardService.updateNotepadData(dashboardItemId, any)).thenAnswer((_) async {});

    // Find and tap the save button.
    // await tester.tap(find.byIcon(Icons.save));
    // await tester.pumpAndSettle(); // Process animations like SnackBar.

    // Verify that a SnackBar appears (if save is successful and shows one).
    // This depends on the actual implementation of _saveNote's UI feedback.
    // expect(find.text('Note saved!'), findsOneWidget);
    // This part is commented out as full save test needs DI or more complex setup.
  });

  testWidgets('NotepadWidget save button interaction (conceptual)', (WidgetTester tester) async {
    // This test outlines how one might test the save button if DashboardService was injectable.
    final initialData = NotepadData(content: 'Test content');
    const dashboardItemId = 'test-id';

    // Assume NotepadWidget is refactored to take DashboardService via constructor
    // final notepadWidget = NotepadWidget(
    //   notepadData: initialData,
    //   dashboardItemId: dashboardItemId,
    //   dashboardService: mockDashboardService,
    // );

    // await tester.pumpWidget(MaterialApp(home: Scaffold(body: notepadWidget)));

    // when(mockDashboardService.updateNotepadData(
    //   dashboardItemId,
    //   anyNamed('newNotepadData') // Use anyNamed for objects
    // )).thenAnswer((_) async {});

    // await tester.enterText(find.byType(TextFormField), 'New text');
    // await tester.tap(find.byIcon(Icons.save));
    // await tester.pump();

    // verify(mockDashboardService.updateNotepadData(
    //   dashboardItemId,
    //   anyNamed('newNotepadData')
    // )).called(1);

    // This test is conceptual due to current NotepadWidget design.
    expect(true, isTrue, reason: "Conceptual test, actual save interaction test requires NotepadWidget DI refactor.");
  });
}
